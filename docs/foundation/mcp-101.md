# MCP & Tools 101 (Analogy + System Fit)

## Quick Analogy (Restaurant)
- LLMs are the chefs: they know how to think and draft responses.
- Tools are kitchen stations: each station performs one specific type of task.
- MCP is the ticket window: it is the standard way the chef sends a request to
  a station and gets results back without walking into the kitchen.

## How It Maps to This Repo
- **LiteLLM** is the host stand: all model calls go through it and it routes to
  the correct backend (MLX, OpenVINO, OptiLLM, etc.).
- **MCP servers** are tool stations: each exposes one or more tools
  (search, model-load, repo-scan, etc.).
- **TinyAgents** are the waiters: they receive user intent, decide which model
  and tools to use, and send MCP requests.

## Why This Pattern Works
- Tools can be added or replaced without changing the models.
- Models can be swapped without breaking tools.
- Permissions, logging, and networking stay centralized.
- The system scales by adding services, not by modifying clients.

## Typical Flow
1) User asks a question via TinyAgents.
2) TinyAgents sends a model request to LiteLLM.
3) If a tool is needed, TinyAgents calls an MCP tool server.
4) Tool results return to TinyAgents, which uses LiteLLM to finalize the reply.

## Practical Example (Search)
- Client calls LiteLLM `/v1/search`.
- LiteLLM forwards to SearXNG.
- Results return to the client, same API base and auth as everything else.

## Future Expansion
- MCP tools can wrap scripts like `mlxctl` so agents can load/unload models.
- Registry entries keep tools discoverable and versioned.
- Add new tools by adding an MCP server and updating the registry.
