#!/usr/bin/env python3
import argparse
import json
import os
import shutil
import subprocess
import sys
import urllib.error
import urllib.request
from pathlib import Path

DEFAULT_REGISTRY = os.path.expanduser("~/models/converted_models/registry.json")
DEFAULT_PROFILE_DIR = Path("/home/christopherbailey/homelab-llm/platform/ops/ov-profiles")
DEFAULT_SERVER_URL = "http://127.0.0.1:9000"
WARM_SCRIPT = Path("/home/christopherbailey/homelab-llm/layer-inference/ov-llm-server/scripts/ov-warm-models")
CONVERT_SCRIPT = Path("/home/christopherbailey/homelab-llm/layer-inference/ov-llm-server/scripts/ov-convert-model")
DEFAULT_OUT_ROOT = Path("/home/christopherbailey/models/converted_models")
DEFAULT_OG_ROOT = Path("/mnt/seagate/og_models")

ENSEMBLES = {}


def _registry_path():
    return Path(os.environ.get("OV_REGISTRY_PATH", DEFAULT_REGISTRY))


def _load_registry(path: Path):
    if not path.exists():
        raise FileNotFoundError(f"registry not found: {path}")
    return json.loads(path.read_text() or "{}")


def _print_json(data):
    print(json.dumps(data, indent=2, sort_keys=True))


def _http_get_json(url: str):
    try:
        with urllib.request.urlopen(url, timeout=5) as resp:
            return json.loads(resp.read().decode("utf-8"))
    except urllib.error.HTTPError as exc:
        raise RuntimeError(f"HTTP {exc.code} from {url}") from exc
    except Exception as exc:
        raise RuntimeError(f"Failed to reach {url}: {exc}") from exc


def _slugify(text: str):
    return (
        text.lower()
        .replace("/", "-")
        .replace("_", "-")
        .replace(".", "-")
    )


def _infer_weight_format(name: str):
    if "int4" in name:
        return "int4"
    if "int8" in name:
        return "int8"
    if "fp16" in name:
        return "fp16"
    return "fp16"


def _ensure_registry_entry(name: str, path: Path, task: str, weight_format: str):
    reg_path = _registry_path()
    if not reg_path.exists():
        reg_path.parent.mkdir(parents=True, exist_ok=True)
        reg_path.write_text(json.dumps({"version": 1, "models": {}}, indent=2))
    data = json.loads(reg_path.read_text() or "{}")
    data.setdefault("version", 1)
    models = data.setdefault("models", {})
    models[name] = {
        "path": str(path),
        "task": task,
        "weight_format": weight_format,
    }
    reg_path.write_text(json.dumps(data, indent=2, sort_keys=True) + "\n")


def _download_openvino_ir(repo: str, name: str, task: str):
    try:
        from huggingface_hub import snapshot_download
    except ImportError as exc:
        raise SystemExit("huggingface_hub is required for downloads. Install it first.") from exc

    out_root = Path(os.environ.get("OV_MODEL_OUT", DEFAULT_OUT_ROOT))
    out_root.mkdir(parents=True, exist_ok=True)
    dest = out_root / name
    if dest.exists():
        return dest
    snapshot = snapshot_download(repo_id=repo, repo_type="model")
    shutil.copytree(snapshot, dest, symlinks=False)
    weight_format = _infer_weight_format(name)
    _ensure_registry_entry(
        name,
        dest / f"task-text-generation-with-past__wf-{weight_format}",
        task,
        weight_format,
    )
    return dest


def cmd_ensure(args):
    repo = args.repo
    name = args.name or _slugify(repo.split("/", 1)[1])
    weight_format = args.weight_format or _infer_weight_format(name)
    task = args.task

    if repo.startswith("OpenVINO/"):
        _download_openvino_ir(repo, name, task)
        print(f"downloaded OV IR: {name}")
        return

    if not CONVERT_SCRIPT.exists():
        raise SystemExit(f"convert script not found: {CONVERT_SCRIPT}")
    env = os.environ.copy()
    env["OV_MODEL_OG"] = str(DEFAULT_OG_ROOT)
    env["OV_MODEL_OUT"] = str(DEFAULT_OUT_ROOT)
    env["OV_MODEL_OG_REMOTE"] = ""
    cmd = [
        str(CONVERT_SCRIPT),
        "--model",
        repo,
        "--weight-format",
        weight_format,
        "--task",
        task,
    ]
    proc = subprocess.run(
        cmd,
        input=(name + "\n").encode("utf-8"),
        env=env,
        check=False,
    )
    if proc.returncode != 0:
        raise SystemExit(f"conversion failed for {repo}")
    print(f"converted: {name}")
def cmd_list(_args):
    registry = _load_registry(_registry_path())
    models = registry.get("models", {})
    rows = []
    for name, meta in sorted(models.items()):
        rows.append(
            {
                "name": name,
                "path": meta.get("path"),
                "task": meta.get("task"),
                "weight_format": meta.get("weight_format"),
            }
        )
    _print_json({"count": len(rows), "models": rows})


def cmd_status(args):
    url = args.server_url.rstrip("/") + "/v1/models"
    data = _http_get_json(url)
    _print_json(data)


def _load_profile(path: Path):
    if not path.exists():
        raise FileNotFoundError(f"profile not found: {path}")
    models = []
    for line in path.read_text().splitlines():
        stripped = line.strip()
        if not stripped or stripped.startswith("#"):
            continue
        models.append(stripped)
    return models


def _run_warm(models, server_url):
    if not WARM_SCRIPT.exists():
        raise FileNotFoundError(f"warm script not found: {WARM_SCRIPT}")
    env = os.environ.copy()
    env["OV_SERVER_URL"] = server_url
    cmd = [str(WARM_SCRIPT)] + list(models)
    return subprocess.call(cmd, env=env)


def cmd_warm(args):
    if args.all:
        models = []
    else:
        models = args.models
    if not args.all and not models:
        raise SystemExit("Provide one or more model names, or use --all.")
    exit_code = _run_warm(models, args.server_url)
    raise SystemExit(exit_code)


def cmd_profiles(args):
    if not args.profile_dir.exists():
        raise SystemExit(f"profile dir not found: {args.profile_dir}")
    profiles = sorted(p.name for p in args.profile_dir.glob("*.txt"))
    _print_json({"count": len(profiles), "profiles": profiles})


def cmd_warm_profile(args):
    profile_path = args.profile_dir / f"{args.profile}.txt"
    models = _load_profile(profile_path)
    if not models:
        raise SystemExit(f"profile {args.profile} is empty")
    exit_code = _run_warm(models, args.server_url)
    raise SystemExit(exit_code)


def cmd_ensemble(args):
    models = ENSEMBLES.get(args.name)
    if not models:
        raise SystemExit(f"unknown ensemble: {args.name}")
    exit_code = _run_warm(models, args.server_url)
    raise SystemExit(exit_code)


def build_parser():
    parser = argparse.ArgumentParser(description="OpenVINO model controller (ovctl)")
    parser.add_argument(
        "--server-url",
        default=DEFAULT_SERVER_URL,
        help="OpenVINO server base URL (default: http://127.0.0.1:9000)",
    )
    parser.add_argument(
        "--profile-dir",
        type=Path,
        default=DEFAULT_PROFILE_DIR,
        help="Directory containing profile .txt files",
    )
    sub = parser.add_subparsers(dest="command", required=True)

    sub.add_parser("list", help="List models in the OpenVINO registry")
    sub.add_parser("status", help="Show /v1/models output from the server")

    warm = sub.add_parser("warm", help="Warm one or more models (or all)")
    warm.add_argument("models", nargs="*", help="Model names to warm")
    warm.add_argument("--all", action="store_true", help="Warm all registry models")

    sub.add_parser("profiles", help="List available warm profiles")
    warm_profile = sub.add_parser("warm-profile", help="Warm a named profile")
    warm_profile.add_argument("profile", help="Profile name (without .txt)")
    ensemble = sub.add_parser("ensemble", help="Warm an OptiLLM OV ensemble")
    ensemble.add_argument("name", help=f"Ensemble name ({', '.join(sorted(ENSEMBLES))})")
    ensure = sub.add_parser("ensure", help="Download/convert and register a model")
    ensure.add_argument("repo", help="Hugging Face repo id")
    ensure.add_argument("--name", help="Canonical model id (ov-...)")
    ensure.add_argument("--weight-format", choices=["fp16", "int8", "int4"])
    ensure.add_argument("--task", default="text-generation-with-past")

    return parser


def main():
    parser = build_parser()
    args = parser.parse_args()
    if args.command == "list":
        cmd_list(args)
    elif args.command == "status":
        cmd_status(args)
    elif args.command == "warm":
        cmd_warm(args)
    elif args.command == "profiles":
        cmd_profiles(args)
    elif args.command == "warm-profile":
        cmd_warm_profile(args)
    elif args.command == "ensure":
        cmd_ensure(args)
    elif args.command == "ensemble":
        cmd_ensemble(args)
    else:
        raise SystemExit(f"Unknown command: {args.command}")


if __name__ == "__main__":
    main()
